\chapter{Resumen en Castellano}

De acuerdo al artículo 22 de la Normativa Reguladora de los Estudios de Doctorado de la Universidad Rey Juan Carlos, aprobada en Consejo de Gobierno de 07/06/2019, se provee un resumen en castellano del contenido completo de la tesis, incluyendo específicamente los antecedentes, objetivos, metodología, resultados y conclusiones obtenidas.

\section{Intoducción}

En ingeniería de software, los desarrolladores colaboran para crear productos de software utilizando Sistemas de Control de Versiones (VCS, por sus siglas en inglés), como Git. 
Los VCS permiten manejar, coordinar y organizar el desarrollo de productos de software, y los cambios que se realizan durante el proceso se agrupan en una revisión o "commit". 
Los VCS son importantes para el mantenimiento y evolución del software, y una tarea común es la localización y corrección de errores. 
El estado del arte más reconocido en este campo es el SZZ, un algoritmo basado en la identificación del cambio que corrige el error para analizar las líneas que han sido modificadas o eliminadas, asumiendo que el último cambio realizado en esas líneas antes de la corrección fue el cambio que introdujo el error. 
Una de las principales limitaciones es cuando la premisa del algoritmo no se cumpla: que las lineas que introdujeron el error no sean
las mismas que posteriormente se arreglaron
En 2018, Gema Rodríguez presentó una tesis doctoral que propone un modelo teórico para mejorar la identificación del cambio que introdujo el error, basado en la idea de un "test perfecto" para verificar la presencia del error en los cambios anteriores del código. 
Sin embargo, la operacionalización del modelo teórico tiene desafíos debido a la dificultad de encontrar un "test perfecto" y la imposibilidad de compilar o ejecutar código de versiones anteriores. 
El objetivo de la tesis es tratar estas limitaciones y adquirir conocimiento empírico para operacionalizar el modelo teórico del "test perfecto".

\section{Hipótesis y objetivos}

En durante el desarrollo de un proyecto software, cuando se detecta un error, es común que no solo se corrija, sino que también se implementa una prueba para verificar que el error no vuelva a aparecer (conocido como prueba de regresión). 
Puede haber diferentes ciclos de vida para un error, desde haber existido en el código desde el primer día en que se implementó la funcionalidad, hasta haberse incorporado en algún momento del ciclo de vida del proyecto.
La hipótesis de esta tesis es que las pruebas implementadas al corregir el error pueden usarse para determinar si el error fue una regresión y utilizarse como operacionalización del "test perfecto" definido en el modelo teórico del trabajo previo. 
Sería suficiente ejecutar esta prueba contra versiones anteriores del código. 
Si se encuentra una versión en la que la prueba pasa, entonces en esa versión el error no existía, por lo que ha sido una regresión. 
Si no se encuentra ninguna versión anterior en la que la prueba pase, entonces el error no es una regresión, porque la funcionalidad nunca funcionó correctamente, o al menos no exactamente como se verificó mediante la prueba.

El objetivo principal de esta tesis es validar la hipótesis propuesta, con el objetivo de poner en práctica el modelo teórico propuesto en la literatura. 
De las limitaciones señaladas por los autores de este modelo, surgen objetivos particulares relacionados con el estudio de la historia de los proyectos para comprender la viabilidad de nuestra propuesta. 
Los objetivos de la tesis serán tres y corresponden a tres proyectos de investigación que se complementan entre sí:
\begin{itemize}
    \item Verificar en qué medida es posible construir commits anteriores de un proyecto. Para poder llevar a cabo la ejecución de pruebas en el pasado, es necesario cumplir con la condición previa de que este código se pueda construir: lo que significa que se pueden descargar sus dependencias y compilar el código (si el lenguaje lo requiere). Exiten trabajos previos sobre este tema que pretendemos validar y ampliar.
    \item Verificar en qué medida es posible ejecutar las pruebas en el pasado. Este objetivo amplía el propósito del anterior, extendiéndolo mediante la prueba de ejecutar las pruebas después de que el código haya sido compilado. Como no hay trabajos previos sobre este tema (en el momento de escribir esta tesis), pretendemos proponer nuevas métricas que nos ayuden a evaluar la cobertura proporcionada por las pruebas a nivel del proyecto.
    \item Aplicar el conocimiento adquirido al alcanzar los objetivos anteriores para verificar nuestra hipótesis, que es posible resolver nuestro objetivo inicial: validar la hipótesis de que es posible utilizar las pruebas de regresión como una "prueba perfecta" siguiendo el modelo teórico propuesto en la literatura. Para ello, ejecutaremos pruebas de regresión a lo largo de la historia de commits del proyecto para detectar el cambio que introdujo el error.
\end{itemize}



\section{Propuesta metodológica}

\section{Resultados}

\section{Conclusiones y trabajos futuros}

En esta tesis se han estudiado en detalle dos propiedades de la evolución del software: la compilabilidad del software en sus versiones pasadas y la capacidad de ejecutar pruebas también en versiones anteriores del código. 
Además, a partir de lo aprendido en estos estudios, se ha propuesto una herramienta para detectar el cambio que introdujo un error en el código haciendo uso del historial de cambios y de las pruebas de regresión. 

En el Capítulo~\ref{chapter:buildability}, se llevó a cabo un estudio de replicación y reproducción del trabajo de Tufano et al.~\cite{tufano2017there} sobre la compilabilidad de la historia de los commits anteriores de un proyecto. Los resultados obtenidos incluyen pautas y directrices para paquetes de reproducción, un conjunto de datos y software para estudiar la degradación a largo plazo de la compilabilidad, y evidencia sobre cómo la compilabilidad se degrada con el tiempo y cómo se puede mitigar. 
En el Capítulo~\ref{chapter:testability}, se realizó un análisis empírico de la capacidad de prueba de instantáneas pasadas de proyectos, y se propuso un marco para analizar esto en el futuro. El alto grado de variabilidad en la capacidad de prueba se encontró en la mayoría de las instantáneas. 
En el Capítulo~\ref{chapter:bug-hunter}, se propuso la operacionalización de un método teórico para detectar el cambio que introdujo un error a través de pruebas de regresión. 
Se generó, además, un conjunto de datos de manera automática de estos los cambios localizados, que se pueden utilizar para evaluar otros métodos que detectan los cambios que introdujeron errores.

A lo largo de este proyecto de investigación, se ha generado un artículo publicado en la revista \textit{Empirical Software Engineering}, situada en el el primer cuartil (Q1) de su campo, correspondiente al Capitulo~\ref{chapter:buildability}. 
El Capítulo~\ref{chapter:testability} está planteado como publicación en la revista \textit{Software Evolution and Process}. 
Por último, la investigación recogida en el Capítulo~\ref{chapter:bug-hunter} ha sido mandada a la revista \textit{Empirical Software Engineering} y se encuentra en proceso de revisión.

La tesis doctoral presentada se limita a proyectos escritos en el lenguaje de programación Java, mayormente librerías de programación cuya mayoría de pruebas son unitarias. Por lo tanto, se necesitan más investigaciones para extraer conclusiones generales sobre la compilabilidad y prueba de instantáneas pasadas, identificar cambios que introdujeron errores y aplicarlo a otros lenguajes de programación y proyectos con diferentes prácticas de prueba. En el Capítulo~\ref{chapter:testability}, se destaca la limitación de no tener acceso a la información de compilación y ejecución de pruebas de instantáneas pasadas debido a la falta de sistemas de integración continua accesibles públicamente. 
Por lo tanto, un posible trabajo futuro sería crear un nuevo conjunto de datos de construcciones y ejecuciones de pruebas que nos ayuden a comprender cómo se comportaban las pruebas en el momento momento en que se ejecutaron y en el contexto adecuado.
En el Capítulo~\ref{chapter:bug-hunter}, se propone una herramienta para buscar exhaustivamente el cambio que introdujo un error, pero esta herramienta también tiene limitaciones debido a la dificultad para reproducir el contexto de prueba y al tiempo requerido para calcular los resultados de ejecución de prueba en la historia de cambios. Se plantea una investigación futura que combine la herramienta propuesta con las últimas implementaciones de SZZ para mejorar su eficacia.