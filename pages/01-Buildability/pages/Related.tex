The build process and the errors preventing correct builds, have been an active area of research during the last years.
One of the most influential empirical studies in this area was authored by Seo et al., who examined 26.6 million builds from Google's centralized build systems, analyzing compilation errors in failed builds. As a result, an error taxonomy was provided based on log patterns~\cite{Seo:2014:PBE:2568225.2568255}.
Sulír and Porubän examined the builds of more than 7,000 Java projects, but only for their last commit~\cite{Sulir:2016:QSJ:3001878.3001882}. 
Other investigations have also focused on errors related to build failures. 
Rausch et al. address specifically the reasons why builds fail in the context of CI environments~\cite{Rausch:2017:EAB:3104188.3104231}.
Travis logs from 14 open-source projects were analyzed, finding that a significant fraction of errors corresponded to tests that failed because of a failure in a previous build.
The study analyzed the build logs from the point of view of continuous integration systems (snapshot build and test execution), but it did not include a reproduction of the builds.
Some authors have emphasized the importance of historic compilability to propose repair tools for failed builds.
Using a taxonomy for the root causes of build failures found in 86 out of the 200 most popular Java projects in GitHub, it was demonstrated that 52 of these failures could be resolved in an automated manner~\cite{hassan2017automatic}.
And the \texttt{HireBuild} tool was able to fix 11 out of 24 reproducible build failures using fix patterns automatically generated from existing build script fixes and recommending fix patterns based on build log similarity~\cite{HireBuild}.
None of the previous studies considered historic compilability, which is the subject of our study. They were in general based on the analysis of logs: in comparison, our studies perform our own building processes, starting from scratch with the source code available in the analyzed snapshots.

A related area to compilability is build reproducibility: \emph{``the ability to generate byte-to-byte identical binaries from the source code of a project version, no matter who builds the binary, when or in which machine''}~\cite{RepBldsDebian:2018:Online}. 
Reproducible builds create a verifiable path from human readable source code to the binary code used by computers, and are gaining relevance~\cite{cito2017empirical,maudoux2018correct,deCarnedeCarnavalet:2014:CIV:2664243.2664288,perry2014reproducible}. 
Software compilations, such as Debian and other Linux-based distributions, have a strong interest in the build reproducibility~\cite{RepBlds:2017:Online,RepBldsDebian:2018:Online}. Obtaining reproducible builds in Debian has been addressed in~\cite{Glukhova:Thesis:2017} and~\cite{Ren:2018:ALU:3180155.3180224}, which present tools to ensure reproducibility, and a framework for detecting and fixing packages with problems. 
However, they focus on the latest version, not dealing with past reproducibility.

The reproducibility of builds is also interesting from a security point of view.
Some works focus on bringing security into the software development life cycle, considering build reproducibility as one of the main issues to be taken into account. Proposals have been presented to use reproducible builds in the context of security-critical open source software~\cite{deCarnedeCarnavalet:2014:CIV:2664243.2664288}, decentralized software-update frameworks including build verifiers~\cite{nikitin2017chainiac}, systems to ensure binary transparency~\cite{hassan2017automatic}, or enhancing trust in software through reproducible builds~\cite{Skrimstad:Thesis:2018}.
Even when our work is relevant to obtain reproducible builds of past versions of the software, we have not dealt with the details needed to ensure it.

Compilability of past versions of a program has been used instrumentally in research or industrial activities.
This is the case for bug location~\cite{Sliwerski:2005:CIF:1083142.1083147,Asaduzzaman:2012:BIC:2664446.2664463,Murgia:2010:MLA:1852786.1852794,Zimmermann:2006:MVA:1137983.1138001,Zimmermann2008}.
When locating bugs, techniques like \texttt{git bisect} may be used to traverse the project history of commits back to the past, to find the change that introduced a bug~\cite{spinellis2012git,meneely2013patch}. In these cases, the utility of the technique is limited to tools performing static analysis, except when automatic compilability of past snapshots can be ensured -- then, the debugged system can be also analyzed dynamically.
Some authors have proposed metrics to evaluate the stability of project builds over time~\cite{6405296}.
Others have addressed the problem in an indirect way, for example when trying to run mutant tests in previous versions of several software projects~\cite{Just:2014:MVS:2635868.2635929} provided by Defects4J~\cite{Just:2014:DDE:2610384.2628055}. However, none of those studies systematically addresses the analysis of the compilability of past versions of real systems.

Finally, we already mentioned Tufano et al.'s work as the direct precedent of the studies we present in this manuscript~\cite{tufano2017there}. Thus, its methodology and results will be discussed in detail later in this chapter.
