\section{Motivation}

In software engineering, developers collaborate with each other in order to develop a software product. 
Software developers have been assisted for years by Version Control Systems (VCS). 
These systems have made it possible to manage, coordinate and organize the development of software products. 
During software development, developers implement several changes to the product in order to introduce new functionality or improve pre-existing ones (refactoring or bug fixes). 
These changes can be grouped into a revision, the minimum unit in which a VCS allows us to version our software. This revision is also known as a "commit". 
One of the most popular and dominant VCS in recent years has been Git~\cite{VersionControlSystemSurvey:2022:Online}.
%Git is a distributed version control system that allows developers to work locally and collaborate with other developers.

Within software evolution and maintenance, one of the main activities performed by developers is bug fixing. 
When using, these bugs were, at that moment, changes introduced in the change history as commits. 
The fixes to these bugs are made through changes that are also reflected in the VCS as a fix commit. 
In other words, both the changes that introduced the bug and the one that fixed the bug are recorded in the VCS. 
From this premise, proposals have emerged to be able to locate the change that introduced the bug from the change that fixed it. 
One of the most relevant proposals for locating the change that introduced the bug is the SZZ algorithm~\cite{Sliwerski:2005:CIF:1083142.1083147}. 
This algorithm starts from the premise that the same lines of code that were modified or deleted in the fix changes are the ones that contained the bug. 
In this way, the change history of a software project could be used to search for the change that introduced or modified those lines and thus be able to know which versions of the project are affected by the bug.

The SZZ algorithm has been for many years the state of the art when locating the change that induced an error. 
In 2018, Gema Rodriguez presented her PhD. Thesis~\cite{rodriguez2018towards}, in which she exposed the limitations of this algorithm and all those that have been derived from it, finding several examples in which this algorithm failed in its purpose. 
In her research and as part of her thesis, the author proposed a theoretical model for the identification of the change that introduced a bug, trying to improve the state of the art. 
This model, in essence, was based on the idea of the "perfect test", a theoretical construct that was able to check if a bug was present or not in commits prior to the change that fixed it. The author of this work explained the difficulties in operationalizing this theoretical model. 
Among the limitations encountered, she points out the difficulty of finding a candidate to be the "perfect test", the impossibility of compiling some code revisions in the past, or the impossibility of executing code of the present (the perfect test) in the commits of the past.

The motivation of my PhD. Thesis is to deal with these limitations, to acquire empirical knowledge of the proposed problems and to operationalize Gema's theoretical model.

\section{Hypothesis}

In software projects, there is a common practice that when a bug is detected, not only is it fixed but also a test is implemented to verify that the bug does not reappear (also known as regression testing). 
That bug may have had different life cycles. 
For example, it is possible that the bug has always existed in the code, since the first day the functionality was implemented. 
On the other hand, it is also possible that the bug was a regression, in which case, at some point in the project life cycle, the bug did not exist and was somehow incorporated into the code. 

Our hypothesis is that the tests implemented when the bug is fixed can be used to determine whether the bug was a regression and be the operationalization of the "perfect test" defined in the theoretical model of the previous work. 
It would be enough to run this test with previous versions of the code. 
If a version is found in which the test passes, then in that version the bug did not exist, and therefore it has been a regression. 
If no previous version is found in which the test passes, then the bug is not a regression, because the functionality never worked correctly, or at least not exactly as verified by the test.

\section{Objectives}

\section{Contributions}

\section{Organization of the thesis}